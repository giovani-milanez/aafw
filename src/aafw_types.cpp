/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "aafw/aafw_types.h"

#include <algorithm>

namespace aafw {

int _kACStatusValues[] = {
  ACStatus::granted,
  ACStatus::rejection
};
const char* _kACStatusNames[] = {
  "granted",
  "rejection"
};
const std::map<int, const char*> _ACStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kACStatusValues, _kACStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kACFailureInfoValues[] = {
  ACFailureInfo::badAlg,
  ACFailureInfo::badRequest,
  ACFailureInfo::badDataFormat,
  ACFailureInfo::notApproved,
  ACFailureInfo::unacceptedExtension,
  ACFailureInfo::untrustedRequester,
  ACFailureInfo::untrustedHolder,
  ACFailureInfo::unsupportedAttribute,
  ACFailureInfo::unsupportedTemplate,
  ACFailureInfo::unknownSerial,
  ACFailureInfo::systemFailure
};
const char* _kACFailureInfoNames[] = {
  "badAlg",
  "badRequest",
  "badDataFormat",
  "notApproved",
  "unacceptedExtension",
  "untrustedRequester",
  "untrustedHolder",
  "unsupportedAttribute",
  "unsupportedTemplate",
  "unknownSerial",
  "systemFailure"
};
const std::map<int, const char*> _ACFailureInfo_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kACFailureInfoValues, _kACFailureInfoNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* ACValidity::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t ACValidity::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t ACValidity::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->notBeforeEpoch);
          this->__isset.notBeforeEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->notAfterEpoch);
          this->__isset.notAfterEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACValidity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACValidity");

  xfer += oprot->writeFieldBegin("notBeforeEpoch", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->notBeforeEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("notAfterEpoch", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->notAfterEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACValidity &a, ACValidity &b) {
  using ::std::swap;
  swap(a.notBeforeEpoch, b.notBeforeEpoch);
  swap(a.notAfterEpoch, b.notAfterEpoch);
  swap(a.__isset, b.__isset);
}

const char* Extension::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Extension::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Extension::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Extension::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Extension");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Extension &a, Extension &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Attribute::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t Attribute::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t Attribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->values.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readBinary(this->values[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Attribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Attribute");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->values.begin(); _iter5 != this->values.end(); ++_iter5)
    {
      xfer += oprot->writeBinary((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Attribute &a, Attribute &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

const char* BaseCertId::ascii_fingerprint = "8275A3654F3E556315307034EBB995BC";
const uint8_t BaseCertId::binary_fingerprint[16] = {0x82,0x75,0xA3,0x65,0x4F,0x3E,0x55,0x63,0x15,0x30,0x70,0x34,0xEB,0xB9,0x95,0xBC};

uint32_t BaseCertId::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->issuer.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->issuer[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial);
          this->__isset.serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaseCertId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaseCertId");

  xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->issuer.size()));
    std::map<std::string, std::string> ::const_iterator _iter13;
    for (_iter13 = this->issuer.begin(); _iter13 != this->issuer.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaseCertId &a, BaseCertId &b) {
  using ::std::swap;
  swap(a.issuer, b.issuer);
  swap(a.serial, b.serial);
  swap(a.__isset, b.__isset);
}

const char* ACHolder::ascii_fingerprint = "ED08028D26717C4CC517A0512EE103E9";
const uint8_t ACHolder::binary_fingerprint[16] = {0xED,0x08,0x02,0x8D,0x26,0x71,0x7C,0x4C,0xC5,0x17,0xA0,0x51,0x2E,0xE1,0x03,0xE9};

uint32_t ACHolder::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->entityName.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _ktype15;
            ::apache::thrift::protocol::TType _vtype16;
            xfer += iprot->readMapBegin(_ktype15, _vtype16, _size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              std::string _key19;
              xfer += iprot->readString(_key19);
              std::string& _val20 = this->entityName[_key19];
              xfer += iprot->readString(_val20);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.entityName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baseCertId.read(iprot);
          this->__isset.baseCertId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACHolder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACHolder");

  if (this->__isset.entityName) {
    xfer += oprot->writeFieldBegin("entityName", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->entityName.size()));
      std::map<std::string, std::string> ::const_iterator _iter21;
      for (_iter21 = this->entityName.begin(); _iter21 != this->entityName.end(); ++_iter21)
      {
        xfer += oprot->writeString(_iter21->first);
        xfer += oprot->writeString(_iter21->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.baseCertId) {
    xfer += oprot->writeFieldBegin("baseCertId", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->baseCertId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACHolder &a, ACHolder &b) {
  using ::std::swap;
  swap(a.entityName, b.entityName);
  swap(a.baseCertId, b.baseCertId);
  swap(a.__isset, b.__isset);
}

const char* ACInfo::ascii_fingerprint = "73E6257E16DDE85821A97347D14C66C7";
const uint8_t ACInfo::binary_fingerprint[16] = {0x73,0xE6,0x25,0x7E,0x16,0xDD,0xE8,0x58,0x21,0xA9,0x73,0x47,0xD1,0x4C,0x66,0xC7};

uint32_t ACInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->holder.read(iprot);
          this->__isset.holder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->issuer.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              std::string& _val28 = this->issuer[_key27];
              xfer += iprot->readString(_val28);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signatureAlgorithm);
          this->__isset.signatureAlgorithm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->serial);
          this->__isset.serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->validity.read(iprot);
          this->__isset.validity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributes.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->attributes.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += this->attributes[_i33].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extensions.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->extensions.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->extensions[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extensions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACInfo");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holder", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->holder.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->issuer.size()));
    std::map<std::string, std::string> ::const_iterator _iter39;
    for (_iter39 = this->issuer.begin(); _iter39 != this->issuer.end(); ++_iter39)
    {
      xfer += oprot->writeString(_iter39->first);
      xfer += oprot->writeString(_iter39->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signatureAlgorithm", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->signatureAlgorithm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->serial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validity", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->validity.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
    std::vector<Attribute> ::const_iterator _iter40;
    for (_iter40 = this->attributes.begin(); _iter40 != this->attributes.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extensions) {
    xfer += oprot->writeFieldBegin("extensions", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extensions.size()));
      std::vector<Extension> ::const_iterator _iter41;
      for (_iter41 = this->extensions.begin(); _iter41 != this->extensions.end(); ++_iter41)
      {
        xfer += (*_iter41).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACInfo &a, ACInfo &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.holder, b.holder);
  swap(a.issuer, b.issuer);
  swap(a.signatureAlgorithm, b.signatureAlgorithm);
  swap(a.serial, b.serial);
  swap(a.validity, b.validity);
  swap(a.attributes, b.attributes);
  swap(a.extensions, b.extensions);
  swap(a.__isset, b.__isset);
}

const char* AttributeCertificate::ascii_fingerprint = "155EE2BB93263B1B9CA850EF19578E90";
const uint8_t AttributeCertificate::binary_fingerprint[16] = {0x15,0x5E,0xE2,0xBB,0x93,0x26,0x3B,0x1B,0x9C,0xA8,0x50,0xEF,0x19,0x57,0x8E,0x90};

uint32_t AttributeCertificate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->algor);
          this->__isset.algor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pem);
          this->__isset.pem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AttributeCertificate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AttributeCertificate");

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("algor", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->algor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pem", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttributeCertificate &a, AttributeCertificate &b) {
  using ::std::swap;
  swap(a.info, b.info);
  swap(a.algor, b.algor);
  swap(a.signature, b.signature);
  swap(a.pem, b.pem);
  swap(a.__isset, b.__isset);
}

const char* ACIssueInfo::ascii_fingerprint = "7A9929745C961A1466EB1CA2C60E22D6";
const uint8_t ACIssueInfo::binary_fingerprint[16] = {0x7A,0x99,0x29,0x74,0x5C,0x96,0x1A,0x14,0x66,0xEB,0x1C,0xA2,0xC6,0x0E,0x22,0xD6};

uint32_t ACIssueInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->holder.read(iprot);
          this->__isset.holder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->templateId);
          this->__isset.templateId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->issuer.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              std::string _key47;
              xfer += iprot->readString(_key47);
              std::string& _val48 = this->issuer[_key47];
              xfer += iprot->readString(_val48);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->validity.read(iprot);
          this->__isset.validity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributes.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->attributes.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += this->attributes[_i53].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extensions.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->extensions.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->extensions[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extensions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACIssueInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACIssueInfo");

  xfer += oprot->writeFieldBegin("holder", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->holder.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.templateId) {
    xfer += oprot->writeFieldBegin("templateId", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->templateId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.issuer) {
    xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->issuer.size()));
      std::map<std::string, std::string> ::const_iterator _iter59;
      for (_iter59 = this->issuer.begin(); _iter59 != this->issuer.end(); ++_iter59)
      {
        xfer += oprot->writeString(_iter59->first);
        xfer += oprot->writeString(_iter59->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validity) {
    xfer += oprot->writeFieldBegin("validity", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->validity.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
      std::vector<Attribute> ::const_iterator _iter60;
      for (_iter60 = this->attributes.begin(); _iter60 != this->attributes.end(); ++_iter60)
      {
        xfer += (*_iter60).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extensions) {
    xfer += oprot->writeFieldBegin("extensions", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extensions.size()));
      std::vector<Extension> ::const_iterator _iter61;
      for (_iter61 = this->extensions.begin(); _iter61 != this->extensions.end(); ++_iter61)
      {
        xfer += (*_iter61).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACIssueInfo &a, ACIssueInfo &b) {
  using ::std::swap;
  swap(a.holder, b.holder);
  swap(a.templateId, b.templateId);
  swap(a.issuer, b.issuer);
  swap(a.validity, b.validity);
  swap(a.attributes, b.attributes);
  swap(a.extensions, b.extensions);
  swap(a.__isset, b.__isset);
}

const char* ACSearchInfo::ascii_fingerprint = "280D0848881E85D3A89F4F0549C4B84A";
const uint8_t ACSearchInfo::binary_fingerprint[16] = {0x28,0x0D,0x08,0x48,0x88,0x1E,0x85,0xD3,0xA8,0x9F,0x4F,0x05,0x49,0xC4,0xB8,0x4A};

uint32_t ACSearchInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->holder.read(iprot);
          this->__isset.holder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->attributesOid.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readSetBegin(_etype65, _size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              std::string _elem67;
              xfer += iprot->readString(_elem67);
              this->attributesOid.insert(_elem67);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.attributesOid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACSearchInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACSearchInfo");

  xfer += oprot->writeFieldBegin("holder", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->holder.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributesOid) {
    xfer += oprot->writeFieldBegin("attributesOid", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributesOid.size()));
      std::set<std::string> ::const_iterator _iter68;
      for (_iter68 = this->attributesOid.begin(); _iter68 != this->attributesOid.end(); ++_iter68)
      {
        xfer += oprot->writeString((*_iter68));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACSearchInfo &a, ACSearchInfo &b) {
  using ::std::swap;
  swap(a.holder, b.holder);
  swap(a.attributesOid, b.attributesOid);
  swap(a.__isset, b.__isset);
}

const char* ACReq::ascii_fingerprint = "C43F80A7249CCE97B6AD0D1577B33A26";
const uint8_t ACReq::binary_fingerprint[16] = {0xC4,0x3F,0x80,0xA7,0x24,0x9C,0xCE,0x97,0xB6,0xAD,0x0D,0x15,0x77,0xB3,0x3A,0x26};

uint32_t ACReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->issueInfo.read(iprot);
          this->__isset.issueInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->searchInfo.read(iprot);
          this->__isset.searchInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revInfo);
          this->__isset.revInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACReq");

  if (this->__isset.issueInfo) {
    xfer += oprot->writeFieldBegin("issueInfo", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->issueInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searchInfo) {
    xfer += oprot->writeFieldBegin("searchInfo", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->searchInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revInfo) {
    xfer += oprot->writeFieldBegin("revInfo", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->revInfo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACReq &a, ACReq &b) {
  using ::std::swap;
  swap(a.issueInfo, b.issueInfo);
  swap(a.searchInfo, b.searchInfo);
  swap(a.revInfo, b.revInfo);
  swap(a.__isset, b.__isset);
}

const char* ACStatusInfo::ascii_fingerprint = "DB054474B0C67F2BCDCAC66C0C09AA76";
const uint8_t ACStatusInfo::binary_fingerprint[16] = {0xDB,0x05,0x44,0x74,0xB0,0xC6,0x7F,0x2B,0xCD,0xCA,0xC6,0x6C,0x0C,0x09,0xAA,0x76};

uint32_t ACStatusInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->status = (ACStatus::type)ecast69;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast70;
          xfer += iprot->readI32(ecast70);
          this->failInfo = (ACFailureInfo::type)ecast70;
          this->__isset.failInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->failText);
          this->__isset.failText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACStatusInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACStatusInfo");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.failInfo) {
    xfer += oprot->writeFieldBegin("failInfo", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->failInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.failText) {
    xfer += oprot->writeFieldBegin("failText", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->failText);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACStatusInfo &a, ACStatusInfo &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.failInfo, b.failInfo);
  swap(a.failText, b.failText);
  swap(a.__isset, b.__isset);
}

const char* ACResp::ascii_fingerprint = "5D0F52F1479C6E5B7D6278BEC935EE43";
const uint8_t ACResp::binary_fingerprint[16] = {0x5D,0x0F,0x52,0xF1,0x47,0x9C,0x6E,0x5B,0x7D,0x62,0x78,0xBE,0xC9,0x35,0xEE,0x43};

uint32_t ACResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statusInfo.read(iprot);
          this->__isset.statusInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->acs.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->acs.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->acs[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.acs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ACResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ACResp");

  xfer += oprot->writeFieldBegin("statusInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->statusInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.acs) {
    xfer += oprot->writeFieldBegin("acs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->acs.size()));
      std::vector<AttributeCertificate> ::const_iterator _iter76;
      for (_iter76 = this->acs.begin(); _iter76 != this->acs.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ACResp &a, ACResp &b) {
  using ::std::swap;
  swap(a.statusInfo, b.statusInfo);
  swap(a.acs, b.acs);
  swap(a.__isset, b.__isset);
}

} // namespace
